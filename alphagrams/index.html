<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scrabble Alphagram Game</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      margin: 0;
      padding: 0;
      height: 100vh;
    }
    aside, .results {
      width: 240px;
      padding: 1rem;
      background: #f5f5f5;
      overflow-y: auto;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 1rem;
    }
    .tile {
      background: #eef;
      padding: 0.5rem;
      border-radius: 4px;
      font-weight: bold;
      text-align: center;
    }
    .tile input {
      margin-top: 0.5rem;
      width: 100%;
    }
    .guess-section input {
      padding: 0.5rem;
      width: 200px;
      font-size: 1rem;
    }
    .guess-section button {
      padding: 0.5rem;
      margin-left: 0.5rem;
    }
    h3 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <aside>
    <h3>Filters</h3>
    <label>Min Length: <input type="number" id="minLength" value="4"></label><br>
    <label>Max Length: <input type="number" id="maxLength" value="6"></label><br>
    <label>Regex Pattern: <input type="text" id="pattern" value=""></label><br>
    <label>Exclude Letters: <input type="text" id="excludeLetters" value=""></label><br>
    <label>Min Vowels: <input type="number" id="minVowels" value="0"></label><br>
    <label>Max Vowels: <input type="number" id="maxVowels" value="5"></label><br>
    <label>Alphagram Count: <input type="number" id="alphaCount" value="20"></label><br>
    <label><input type="checkbox" id="newOnly"> New Words Only</label><br>
    <button id="generateButton" onclick="applyFilters()" disabled>Generate Grid</button>
    <button onclick="revealAll()">Reveal All</button>
 <hr>
<h3>Options</h3>
<label>Grid Columns:
  <select id="gridColumns">
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4" selected>4</option>
    <option value="5">5</option>
    <option value="6">6</option>
  </select>
</label><br>

  </aside>
  <main>
    <div id="summary"></div>
    <div class="grid" id="wordGrid"></div>
    <div class="guess-section">
  <input type="text" id="guessBox" placeholder="Your guess">
  <button onclick="submitGuess()">Submit</button>
</div>
  </main>
  <div class="results">
  <div id="correctBox">
    <h3>Correct</h3>
    <div id="correctList"></div>
  </div>
  <hr>
  <div id="wrongBox">
    <h3>Wrong</h3>
    <div id="wrongList"></div>
  </div>
</div>
    
  </div>
  <script>
let wordData = [];
let newWordsSet = new Set();
let userCorrect = new Set();
let userWrong = new Set();
let allWords = new Set();

fetch("https://raw.githubusercontent.com/jalapic/word_games/refs/heads/main/alphagrams/csw24newonly.txt")
  .then(r => r.text())
  .then(text => {
    text.split("\n").forEach(w => newWordsSet.add(w.trim().toUpperCase()));
  });

fetch("https://raw.githubusercontent.com/jalapic/word_games/refs/heads/main/word_builder/CSW25.txt")
  .then(res => res.text())
  .then(text => {
    const words = text.trim().split("\n").map(w => w.trim().toUpperCase());
    words.forEach(w => allWords.add(w));
    const grouped = {};
    for (const word of words) {
      const alpha = word.split('').sort().join('');
      if (!grouped[alpha]) grouped[alpha] = [];
      grouped[alpha].push(word);
    }
    const tileDistribution = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGGBBCCMMPPFFHHVVWWYYKJXQZ".split("");
    const totalTiles = tileDistribution.length;
    const tileCounts = tileDistribution.reduce((acc, ltr) => {
      acc[ltr] = (acc[ltr] || 0) + 1;
      return acc;
    }, {});

    wordData = Object.entries(grouped).map(([alpha, group]) => {
      const length = group[0].length;
      const tileFreq = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('').reduce((acc, l) => {
        acc[l] = (alpha.match(new RegExp(l, 'g')) || []).length;
        return acc;
      }, {});
      const prob = Object.entries(tileFreq).reduce((p, [ltr, cnt]) => {
        const tileProb = (tileCounts[ltr] || 0) / totalTiles;
        return p * Math.pow(tileProb, cnt);
      }, 1);
      const negLogProb = -Math.log10(prob);
      return {
        alpha,
        words: group,
        length,
        vowelCount: (alpha.match(/[AEIOU]/g) || []).length,
        probability: negLogProb
      };
    });

    console.log("âœ… TXT loaded:", wordData.length, "alphagrams");
    document.getElementById("generateButton").disabled = false;
  });

function matchesScrabblePattern(word, pattern) {
  function match(w, p) {
    if (p.length === 0) return w.length === 0;
    if (p[0] === '*') {
      return match(w, p.slice(1)) || (w.length > 0 && match(w.slice(1), p));
    }
    if (w.length === 0) return false;
    if (p.startsWith('[')) {
      const end = p.indexOf(']');
      if (end === -1) return false;
      const set = p.slice(1, end);
      const isNeg = set[0] === '^';
      const chars = isNeg ? set.slice(1) : set;
      const matchChar = w[0].toUpperCase();
      const inSet = chars.toUpperCase().includes(matchChar);
      if ((isNeg && inSet) || (!isNeg && !inSet)) return false;
      return match(w.slice(1), p.slice(end + 1));
    }
    if (p[0] === '.') return match(w.slice(1), p.slice(1));
    if (p[0] === '^') {
      if (w[0].toUpperCase() === p[1].toUpperCase()) return false;
      return match(w.slice(1), p.slice(2));
    }
    return w[0].toUpperCase() === p[0].toUpperCase() && match(w.slice(1), p.slice(1));
  }
  return match(word.toUpperCase(), pattern);
}


function addHooks(word) {
  const hooks = [];
  const prefix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const suffix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let l of prefix) {
    if (allWords.has(l + word)) hooks.push(`<sub>${l.toLowerCase()}</sub>`);
  }
  let hooked = hooks.join("") + word;
  for (let l of suffix) {
    if (allWords.has(word + l)) hooked += `<sub>${l.toLowerCase()}</sub>`;
  }
  return hooked;
}

function updateLists() {
  const correctDiv = document.getElementById("correctList");
  const wrongDiv = document.getElementById("wrongList");
  correctDiv.innerHTML = Array.from(userCorrect).map(w => addHooks(w)).join(", ");
  wrongDiv.innerText = Array.from(userWrong).join(", ");
}

window.applyFilters = function () {
  const minL = +document.getElementById("minLength").value;
  const maxL = +document.getElementById("maxLength").value;
  const patternInput = document.getElementById("pattern").value;
  const excludeLetters = document.getElementById("excludeLetters").value.toUpperCase();
  const minV = +document.getElementById("minVowels").value;
  const maxV = +document.getElementById("maxVowels").value;
  const alphaLimit = +document.getElementById("alphaCount").value;
  const newOnly = document.getElementById("newOnly").checked;

  const grid = document.getElementById("wordGrid");
  const summary = document.getElementById("summary");
const gridCols = +document.getElementById("gridColumns").value;
  grid.innerHTML = "";
  userCorrect.clear();
  userWrong.clear();
  updateLists();

  window.activeTiles = [];

  let filtered = wordData.filter(({ alpha, words, length, vowelCount }) =>
    (!minL || length >= minL) &&
    (!maxL || length <= maxL) &&
    (!patternInput || words.some(w => matchesScrabblePattern(w, patternInput))) &&
    (!excludeLetters || words.every(w => ![...excludeLetters].some(l => w.includes(l)))) &&
    (!minV || vowelCount >= minV) &&
    (!maxV || vowelCount <= maxV) &&
    (!newOnly || words.some(w => newWordsSet.has(w)))
  );

  filtered = filtered.sort(() => Math.random() - 0.5).slice(0, alphaLimit);

  let shown = 0;
  filtered.forEach(({ alpha, words }) => {
    const div = document.createElement("div");
    div.className = "tile";
    div.dataset.alpha = alpha;
    div.dataset.words = JSON.stringify(words);
    div.innerHTML = `${alpha} (${words.length})<br>`;
    grid.appendChild(div);
    shown += words.length;
    window.activeTiles.push({ alpha, words });
  });

  summary.textContent = `${shown} total words to guess.`;
};

window.submitGuess = function () {
  const guess = document.getElementById("guessBox").value.trim().toUpperCase();
  if (!guess) return;
  let found = false;

  document.querySelectorAll(".tile").forEach(tile => {
    const words = JSON.parse(tile.dataset.words);
    if (words.includes(guess)) {
      if (!userCorrect.has(guess)) {
        userCorrect.add(guess);

        const remaining = words.filter(w => !userCorrect.has(w)).length;
        const alpha = tile.dataset.alpha;
        tile.innerHTML = `${alpha} (${remaining})<br>`;

        if (remaining === 0) {
          tile.style.background = '#a5d6a7';
        } else if (remaining === 1) {
          tile.style.background = '#ffe082';
        } else if (remaining <= 2) {
          tile.style.background = '#ffcc80';
        } else {
          tile.style.background = '#bbdefb';
        }
      }
      found = true; // âœ… even if already correct
    }
  });

  if (!found) userWrong.add(guess);
  updateLists();
  document.getElementById("guessBox").value = "";

  // Optional: well done popup if all solved
  const allSolved = Array.from(document.querySelectorAll(".tile")).every(tile => {
    const words = JSON.parse(tile.dataset.words);
    return words.every(w => userCorrect.has(w));
  });

  if (allSolved) {
    const msg = document.createElement("div");
    msg.textContent = "ðŸŽ‰ Well done! All words solved!";
    msg.style.position = "fixed";
    msg.style.top = "40%";
    msg.style.left = "50%";
    msg.style.transform = "translate(-50%, -50%)";
    msg.style.background = "#d4edda";
    msg.style.border = "2px solid #28a745";
    msg.style.padding = "2rem";
    msg.style.fontSize = "1.5rem";
    msg.style.zIndex = 1000;
    msg.style.boxShadow = "0 0 20px rgba(0,0,0,0.3)";
    document.body.appendChild(msg);

    setTimeout(() => msg.remove(), 3000);
  }
};


window.revealAll = function () {
  const popup = document.createElement("div");
  popup.style.position = "fixed";
  popup.style.top = "10%";
  popup.style.left = "10%";
  popup.style.width = "80%";
  popup.style.height = "80%";
  popup.style.overflowY = "scroll";
  popup.style.background = "#fff";
  popup.style.border = "2px solid #333";
  popup.style.padding = "1rem";
  popup.style.zIndex = 1000;

  const closeBtn = document.createElement("button");
  closeBtn.innerText = "Close";
  closeBtn.onclick = () => popup.remove();
  popup.appendChild(closeBtn);
  popup.appendChild(document.createElement("hr"));

  window.activeTiles.forEach(({ alpha, words }) => {
    const section = document.createElement("div");
    const title = document.createElement("h4");
    title.textContent = `${alpha} (${words.length})`;
    const wordList = document.createElement("p");
   wordList.innerHTML = words
  .map(w => {
    const hooked = addHooks(w);
    return userCorrect.has(w) ? hooked : `<span style="color:red">${hooked}</span>`;
  })
  .join(", ");

    section.appendChild(title);
    section.appendChild(wordList);
    popup.appendChild(section);
  });

  document.body.appendChild(popup);
};

document.addEventListener("DOMContentLoaded", function () {
  const box = document.getElementById("guessBox");
  if (box) {
    box.addEventListener("keydown", function (e) {
      if (e.key === "Enter") submitGuess();
    });
  }

  
  const gridSelect = document.getElementById("gridColumns");
  if (gridSelect) {
    gridSelect.addEventListener("change", function () {
      const cols = +this.value;
      const grid = document.getElementById("wordGrid");
      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    });
  }
});



</script>
</body>
</html>
